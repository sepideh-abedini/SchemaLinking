extract_domain_schema_prompt = """[你的角色]
你是一位顶级数据库架构分析师，专注于数据库模式分析与领域特征提取。你的任务是从数据库的所有 schemas（表与字段）中，精准识别该数据库所属领域，并提取 关键领域模式（即该领域中广泛适用、最核心的表结构），以支持业务建模、数据治理和分析优化。

[任务目标]
# 精准识别数据库所属领域，确保筛选出的表符合该领域的核心业务需求。
# 剔除无关表（日志、临时表等）和冗余字段，仅保留关键表，并确保主键、外键和领域特征字段完整。
# 仅输出 JSON 格式数据，严格遵守指定的 JSON 结构，不包含任何额外文本或解释。

1. 领域识别与验证（确保行业匹配）
# 基于表名聚类，推测数据库所属领域（如 Student/Course/Department → 教育，Flight/Airport/Ticket → 航空）。
# 检查字段特征是否符合行业标准，如：
a. 金融. 数据应包含 currency, balance, transaction_amount。
b. 航空. 数据应包含 flight_id, airport_code, departure_time。
c. 电商. 数据应包含 order_id, customer_id, product_price。
# 如果数据库模式无法清晰匹配某一行业，不进行盲目推测，而是以中性方式仅筛选核心表。

2. 关键模式筛选（递进式过滤，确保仅保留核心业务表）
① 必选条件（所有关键表必须满足以下条件）
✅ 必须包含 至少一个主键（PK），确保数据唯一性。
✅ 必须包含 至少一个外键（FK），确保表间存在业务关联。
✅ 表名应符合该领域的核心业务实体（如 Students, Flights, Transactions）。

② 优选条件（满足越多，越倾向保留）
a. 包含 ≥3 个领域特征字段（如 financial_transactions 表应至少有 transaction_id, amount, account_type）。
b. 处于数据库的枢纽位置（即连接多个表的关系表，如 订单表、交易表）。
c. 包含业务时间字段（如 enrollment_date, transaction_date，支持时序分析）。

③ 排除条件（剔除无关表）
a. 表名包含 log/temp/backup/archive（日志、临时、备份表）。
b. 仅含技术性字段（如 create_time, status_flag，且无明显业务字段）。
c. 孤立表（无外键关联其他表，且无明显业务用途）。

3. 关键字段筛选（确保数据完整性）
a. 所有主键（PK）和外键（FK）必须保留，确保数据完整性和可溯源性。
b. 按优先级保留字段（从高到低）：
# [主键]（唯一标识每条记录）
# [外键]（用于连接其他业务表）
⃣# [领域特征字段]（如 flight_number, transaction_amount）
# [业务时间字段]（如 event_time, enrollment_date）
# [描述性字段]（如 备注字段，仅在有业务意义时保留）

✅ 字段必须符合业务语义和数据类型约定（如金额字段应为 decimal，而非 string）。

4. 质量保证机制（确保数据库结构合理性）
✅ 完整性检查
# 所有核心表至少有 1 个外键 连接其他表，避免孤立数据。
# 主外键必须形成完整的连接链路（确保从核心表可以访问所有相关表）。
# 每个核心表必须至少包含：1PK + ≥1FK + ≥2 领域特征字段。

✅ 业务闭环验证
# 数据应能重建关键业务流程（如“学生选课 → 教师授课 → 成绩登记”）。
# 时间字段能构建业务时序（如“入学时间 → 选课时间 → 考试时间”）。
# 数值字段支持业务计算（如“学分累计、账户余额变化”）。

5. JSON 输出格式要求（必须严格遵守）
# 仅输出 JSON 格式数据，不包含任何额外文本或解释。
# 确保 JSON 结构严格符合以下格式，避免结构错乱：
示例如下：
[
    {{
        "column_name": "DEST_AIRPORT_ID",
        "column_types": "integer",
        "meta_data": {{
            "db_id": "airline",
            "table_name": "Airlines"
        }}
    }},
    {{
        "column_name": "FLIGHT_NUMBER",
        "column_types": "varchar",
        "meta_data": {{
            "db_id": "airline",
            "table_name": "Flights"
        }}
    }}
]
# 所有字段必须与数据库实际结构保持一致，不进行额外推测或填充。

### [数据库模式信息]
以下是待分析的数据库模式：

{schema_context}

### 请严格按照上述规则执行，不要进行额外推测或输出解释。
"""

expand_database_schema = """你是一名资深数据库架构师，专注于企业级数据库设计，拥有丰富的数据库建模经验和SQL优化能力。

当前，公司数据库需要升级，以更好地支持业务需求。你的任务是扩展数据库模式（表和列），使其能存储更完整、更细粒度的业务数据，并支持更高级的业务分析和决策。

一、扩展设计目标
你需要围绕数据库的业务场景，按以下原则进行扩展：

1. 新增字段应满足：
紧密匹配业务场景，反映真实业务需求。（如：订单表中增加"支付方式"字段，客户表中增加"忠诚度评分"字段）

提升数据颗粒度，增强数据精细化管理能力。（如：拆分"地址"字段为"省份"、"城市"、"区县"）

支持关键业务分析，便于构建指标体系。（如：增加"订单取消原因"字段，以优化供应链分析）

具有清晰的业务定义，避免字段泛化或冗余。（如："订单状态" 应包括“待支付、已支付、已发货”等业务语义）

2. 新增表的设计应考虑：
优化业务实体建模，明确表的业务作用。（如：新增"客户分群表"用于客户分类管理）

完善业务流程追踪，存储关键业务操作日志。（如：新增"订单审批记录表"跟踪审批节点）

扩展业务主数据，提升数据结构灵活性。（如：新增"促销规则表"支持不同促销活动配置）

强化业务分析能力，引入衍生数据表。（如：新增"销售预测表"存储AI预测结果）

二、元数据规范
1. 每个新增字段必须包含：

业务语义定义（明确字段的业务作用，避免技术性描述）

数据来源（该字段数据从何处生成，如：用户录入、系统计算、外部API）

数据质量规则（如：非空约束、唯一性要求、格式限制）

敏感级别分类（如：公开、内部、敏感、机密）

2. 每个新增表必须明确：

表类型（事实表、维度表、配置表）

数据更新频率（如：实时、每日、每周）

生命周期策略（如：是否有归档或数据清理策略）

关联业务流程编号（与业务流程图的对应关系）

三、输出格式要求
请严格按照以下 JSON 数组格式输出新增的字段和表，仅包含新增的元数据：

json
复制
编辑
[
    {{
        "column_name": "DEST_AIRPORT_ID",
        "column_types": "integer",
        "meta_data": {{
            "db_id": "airline",
            "table_name": "Airlines"
        }}
    }},
    {{
        "column_name": "FLIGHT_NUMBER",
        "column_types": "varchar",
        "meta_data": {{
            "db_id": "airline",
            "table_name": "Flights"
        }}
    }}
]
四、数据库模式
以下是当前数据库的表结构，请基于此结构进行扩展：
{schema_context}

注意：
1. 不要修改现有的表结构，仅在其基础上扩展字段和表。
2. 所有新增字段和表必须符合业务逻辑，避免无意义扩展。
3. 输出严格遵循 JSON 格式，不要添加多余的说明文字。
"""

question_rewriting_prompt = """你是一名高级数据库问题重构专家，专门负责生成语义混淆且符合业务特征的自然语言查询问题。你的任务是基于目标数据库与混淆数据库的共有结构，重写一个新的查询问题，使其在两个数据库的模式兼容性与目标数据库的独特业务特征之间达到平衡。

【重写要求】
1. 结构兼容性：重写后的问题必须基于两个数据库共有的表结构（包括表名、字段名、主外键关系等），确保SQL语句在两个数据库中均可解析通过。
2. 语义区分性：问题设计应隐含目标数据库的独特业务特征，使其更符合目标数据库的查询需求，同时让SQL查询结果在任务上与混淆数据库产生差异。

【优化策略】
1. 信息融合：巧妙嵌入目标数据库独有的业务语义（如“用户流失概率”或“订单生命周期”）到问题中，使其看似普通但实际上偏向目标数据库的查询逻辑。
2. 结构模糊：确保问题不直接暴露目标数据库的独特表或字段，而是使用两者共享的结构，以增强混淆性。
3. 语义锚点：植入目标数据库独有的分析方式，例如特定时间规则（滚动窗口 vs. 自然月度）、数据统计偏好（按交易额 vs. 按用户行为）等，以使SQL在两个数据库中执行后得到的业务结果有所不同。
4. 问题多样性：避免与原问题完全相似，可以调整查询角度、时间维度、分析粒度等，增加问题的变体。

【输出格式】
直接输出最终重写后的自然语言问题，不附加任何分析过程。语言风格保持自然，避免技术性描述（如“数据库表”或“SQL”），使其看起来像真实业务查询。

【输入参数】
原始问题：{question}

目标数据库特征：{target_database}

混淆数据库特征：{confuse_database}

### 输出重写后的优化问题："""

generate_data_prompt = """
你是一个专业的SQL问题生成器，需要根据给定的数据库模式信息生成具有挑战性的自然语言问题及对应的准确SQL查询。请严格遵循以下步骤：

1. 深度模式分析
- 识别所有表的主外键关系，绘制实体关系图（在思维中）
- 标注每个字段的业务含义和数值类型
- 特别注意可能产生歧义的字段命名（如不同表的同名字段）

2. 多样化问题生成（需满足以下至少3项）
☑️ 覆盖不同业务场景（客户分析/库存管理/财务统计等）
☑️ 包含2-3个逻辑层次（筛选->聚合->排序）
☑️ 使用不同类型的表连接（LEFT JOIN/INNER JOIN等）
☑️ 包含嵌套查询或窗口函数
☑️ 设计至少1个需要推导的业务指标（如"用户留存率"等）
☑️ 包含时间范围过滤（需正确处理日期格式）
☑️ 使用聚合函数+HAVING组合

3. SQL构造规范
① 使用ANSI SQL标准语法
② 显式指定JOIN条件（禁止隐式连接）
③ 处理字段歧义时必须使用表别名
④ 包含必要的执行效率优化（如索引字段优先）
⑤ 格式化SQL语句（缩进/换行统一）

4. 严格验证流程
1) 字段存在性检查：确认所有使用字段在对应表中真实存在
2) 连接正确性验证：确保ON条件准确匹配主外键
3) 逻辑一致性检查：逐项核对问题需求与SQL元素的对应关系：
   - SELECT字段是否完整反映问题需求
   - WHERE条件是否覆盖所有筛选维度
   - GROUP BY是否匹配聚合层级
   - 排序方向和字段是否准确
4) 边界测试：验证空值、极值情况下的处理逻辑
5) 结果可执行保证：确保在真实数据库环境能返回预期格式的结果

5. 多样性增强策略
✦ 每生成3个问题后必须切换业务视角
✦ 交替使用基础查询和复杂查询模式
✦ 设计至少20%的问题需要多层嵌套查询
✦ 对常见业务指标使用不同表达方式（如"总量" vs "累计值"）

示例输出（展示2个不同难度案例）：
// 基础案例
{{
  "question": "找出过去一个月订单金额超过5000元且配送地址在北京的客户姓名及联系方式",
  "query": "SELECT c.customer_name, c.phone FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.order_date >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH) AND o.total_amount > 5000 AND o.shipping_address LIKE '%北京%'"
}}

// 高级案例
{{
  "question": "计算每个产品类别中复购率最高的客户，显示客户ID、产品类别名称及其复购次数（复购定义为至少两次购买同类别商品）",
  "query": "WITH purchase_counts AS (SELECT o.customer_id, p.category_id, COUNT(*) AS total_purchases FROM orders o JOIN order_details od ON o.id = od.order_id JOIN products p ON od.product_id = p.id GROUP BY o.customer_id, p.category_id HAVING COUNT(*) >= 2) SELECT pc.customer_id, c.category_name, pc.total_purchases FROM purchase_counts pc JOIN product_categories c ON pc.category_id = c.id WHERE (pc.category_id, pc.total_purchases) IN (SELECT category_id, MAX(total_purchases) FROM purchase_counts GROUP BY category_id)"
}}

格式要求：
- 严格使用JSON格式，仅包含question和query两个字段
- SQL语句使用大写关键字并格式化缩进
- 自然语言问题必须包含明确的筛选条件和业务上下文
- 禁止使用示例中的案例模板

错误预防清单：
1. 避免无效的表连接路径
2. 禁止未限定字段名的歧义引用
3. 防止GROUP BY遗漏非聚合字段
4. 排除未处理NULL值的潜在错误
4. 规避WHERE和HAVING的误用
5. 禁止无别名导致的嵌套查询冲突

### 下面是数据库全部模式信息：
{schema_context}

### 输出：
"""

generate_sql_prompt = """
你是一个专业的SQL工程师，需要通过严谨的多阶段推理过程，将自然语言查询精准转换为可执行的SQL语句。必须严格按照以下步骤执行，并确保最终输出唯一正确的SQL结果：

【核心原则】
a. 100%遵守数据库模式定义
b. 必须识别所有隐含条件
c. 严格验证结果逻辑完备性

【执行框架】
▌阶段1：模式深度解析
1.1 建立表关系图谱：绘制主键/外键映射关系，标注关联方向
1.2 识别关键字段：标记时间字段、状态字段、数值型字段等特殊类型
1.3 记录字段约束：特别关注 NOT NULL、UNIQUE、索引字段

▌阶段2：查询需求解构
2.1 需求要素提取：
1. 目标对象（需要SELECT的字段）
a. 过滤条件（显式条件 + 隐含条件）
b. 聚合需求（SUM/COUNT等）
c. 排序规则（ORDER BY）
d. 数据来源（涉及的表）

2.2 条件推理：
a. 显式条件：直接陈述的时间范围、状态值等
b. 隐含条件：推导未明示但必要的约束（如"最新数据"→ORDER BY + LIMIT）
c. 关联条件：跨表查询时必须的JOIN条件

▌阶段3：逻辑验证体系
3.1 连接验证：
a. 检查JOIN条件是否覆盖所有涉及表
b. 验证ON子句是否使用正确的外键关系
c. 确认连接类型（INNER/LEFT JOIN）是否符合业务逻辑

3.2 条件覆盖检查：
a. 创建条件检查清单，逐个验证每个过滤条件是否实现
b. 特别注意NULL值处理（需显式声明IS NULL/NOT NULL）
c. 验证时间范围边界（包含/排除端点）

3.3 结果模拟验证：
a. 预演SQL执行结果是否符合自然语言描述
b. 检查是否可能产生笛卡尔积
c. 验证聚合字段与GROUP BY的匹配性

▌阶段4：最终优化输出
4.1 语法标准化：
a. 使用显式JOIN代替隐式连接
b. 统一使用AS进行别名定义
c. 优先使用标准SQL函数

4.2 防御性编码：
a. 对字符串参数添加引号转义
b. 对数值型条件显式声明类型
c. 包含必要的schema前缀

【关键约束】
a. 当存在多种实现方式时，选择JOIN路径最短的方案
b. 必须处理字段名歧义问题（使用table.column形式）
c. 禁止SELECT *，必须显式列出字段
d. 时间条件必须指定时区（如无则标注假设）

[输入格式]
数据库模式：{database_schema}

自然语言查询：{user_query}

[输出]
### 仅输出最终的 SQL 语句，不要包含任何其他无关解释内容：
"""

sql_alignment_prompt = """[角色设定]
你是一名精通SQL与自然语言双向转换的数据库架构师，擅长通过逻辑链推演验证结构化查询与自然语言表述的严格等价性。你的核心能力是发现语义鸿沟并精准修正表述。

[任务目标]
通过严格推理验证SQL与自然语言问题的双向唯一映射关系，当且仅当两者语义完全一致时，生成无歧义的最终问题表述。

[验证流程]
1. 深度模式解析
a. 构建表关系图谱：标注主/外键约束、关联基数、索引覆盖字段
b. 识别字段语义：标注枚举值范围、默认值、计算列逻辑
c. 标记时态字段：明确时间字段的时区信息和精度单位

2. SQL逆向工程
a. 解析执行计划维度：
# 显式JOIN vs 隐式JOIN
# 过滤条件执行顺序
# 临时表/CTE的创建逻辑

b. 语义要素提取：
# 投影字段（含字段别名影响）
# 过滤条件（区分条件类型：等值/范围/模糊/空值）
# 聚合维度（GROUP BY粒度与SELECT聚合函数匹配性）
# 排序限制（TOP/LIMIT与ORDER BY的耦合关系）
# 窗口函数作用域

3. 双向语义验证
a. 建立条件约束矩阵：
| 维度 | SQL证据点 | 自然语言对应点 | 等价性判定 |
|-------------|------------------|--------------------|------------|
| 主体表 | FROM/JOIN | 问题主实体提及 | |
| 投影字段 | SELECT列表 | 需求指标明确性 | |
| 过滤条件 | WHERE/HAVING | 条件要素完整性 | |
| 时间范围 | BETWEEN等操作符 | 时间表述精确度 | |
| 聚合层级 | GROUP BY + 聚合函数 | 统计维度声明 | |
| 排序规则 | ORDER BY + LIMIT | 排序需求表述 | |

b. 执行消歧验证：
# 检查WHERE条件是否隐含默认值（如status=1对应"有效订单"）
# 验证比较运算符的语义边界（如">"是否应表述为"超过"）
# 检测字段别名对语义的影响（如total_amount AS revenue）
# 识别未显式声明的关联条件（如跨表字段的隐式JOIN）

4. 问题重构规范
a. 要素排列顺序：
[时间范围] + [主体限定] + [条件约束] + [统计方式] + [排序需求]
b. 强制包含要素：
# 表关联的必要说明（当涉及2个以上表时）
# 聚合函数的文字表述（如"统计总数"对应COUNT(*)）
# 并列条件的逻辑连接词（AND/OR的明确表述）
c. 禁止项：
# 代词使用（"相关数据"等模糊表述）
# 非标准时间表述（"最近"需转为"过去30天"）
# 不完整条件（需补全默认值约束）

[输出协议]
仅返回最终重新优化后的自然语言问题

[输入]
# 数据库模式：{database_schema}

# 自然语言查询：{question}

# SQL 语句：{query}

### 仅输出优化后的自然语言问题：
"""
